# 宏定义命令

```C
// 定义一个宏，用来打印两个变量的值
#define PRINT(x,y) \
	do { \
		printf("x = %d\n", x); \
		printf("y = %d\n", y); \
	} while (0)

int main()
{
    int a = 10, b = 20;
    // 使用if-else语句，根据条件调用宏
    if (a > b)
        PRINT(a,b); // 如果没有do{}while(0)，这里会被分号打断，导致else语句出错
    else
        PRINT(b,a); // 如果没有do{}while(0)，这里会多出一个分号，导致编译警告
    return 0;
}
```

- 为什么要使用`do{}while(0)`，为什么不能直接写？

  这段代码中使用了`do{}while(0)`的宏，是为了让宏的内容在任何地方都能像一个普通的语句一样使用，而不会出现分号或者花括号的问题。

  如果没有`do{}while(0)`，那么宏的末尾就会多出一个分号，这个分号可能会和`if-else`语句中的分号冲突，导致编译警告或者错误。例如，如果你写了这样的代码：

  ```C
  if (a > b) PRINT(a,b); else PRINT(b,a);
  ```

  那么宏展开后就会变成：

  ```C
  if (a > b) 
      printf(“x = %d\n”, a); 
  	printf(“y = %d\n”, b);; 
  else 
      printf(“x = %d\n”, b); 
  	printf(“y = %d\n”, a);;
  ```

  这里第一个分号是宏的末尾，第二个分号是if-else语句的末尾。

  这样就会造成else语句无法正确匹配`if`语句，导致编译错误。而如果使用了`do{}while(0)`，那么宏展开后就会变成：

  ```C
  if (a > b) 
      do 
      { 
          printf(“x = %d\n”, a); 
          printf(“y = %d\n”, b); 
      } 
  	while (0); 
  else 
      do 
      { 
          printf(“x = %d\n”, b); 
          printf(“y = %d\n”, a); 
      } 
  	while (0);
  ```

  这样就不会有多余的分号，也不会影响`if-else`语句的结构。所以，使用`do{}while(0)`的宏可以避免一些潜在的错误和警告。

- `do{}while(0)`的作用

  这个代码中的do{}while(0)的作用是让宏的内容在任何地方都能像一个普通的语句一样使用，而不会出现分号或者花括号的问题。具体来说，它有以下几个优点：

  - 它可以避免空的宏定义导致的编译警告。
  - 它可以在宏内部定义变量，而不会影响外部的作用域。
  - 它可以保证宏的内容只执行一次，而不会因为条件判断或者逗号表达式而重复执行 。
  - 它可以和if-else语句或者其他控制流语句配合使用，而不会出现多余的分号或者花括号的问题 。

  使用do{}while(0)的宏可以提高代码的可读性和安全性。

