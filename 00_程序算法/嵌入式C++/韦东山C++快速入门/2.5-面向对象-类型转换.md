# 类型转换

C++类型转换分为隐式类型转换和显式类型转换，其中隐式类型转换由编译器自动完成，这里只讨论显式类型转换。¹ 

C++中有四种显式类型转换方式：static_cast、dynamic_cast、const_cast和reinterpret_cast。⁴⁵²³

- static_cast：用于将一种数据类型强制转换为另一种数据类型，但是不能转换掉底层const、volatile和__unaligned属性。¹
- dynamic_cast：用于将基类的指针或引用安全地转换为派生类的指针或引用。⁴
- const_cast：用于将const变量的常量性去除。⁵
- reinterpret_cast：用于将一个指针转换为其他类型的指针，但是不能用于函数指针和void指针之间的转换。²

[(1) C++笔记 · C++类型转换 - 知乎 - 知乎专栏.](https://zhuanlan.zhihu.com/p/27966225) 

[(2) C++ 类型转换（方法太多，凌乱了） - 知乎 - 知乎专栏.]( https://zhuanlan.zhihu.com/p/448952948)

[(3) c++类型转换 - 知乎 - 知乎专栏.]( https://zhuanlan.zhihu.com/p/615061456)

[(4) C++中的4种类型转换 - CSDN博客.](https://blog.csdn.net/weixin_42482896/article/details/88939439) 

[(5) C/C++类型转换(一) - 知乎 - 知乎专栏.](https://zhuanlan.zhihu.com/p/93909952)



## 例程1:reinterpret_cast

格式：`reinterpret_cast<type-id> (expression)`

相当于C风格的用小括号`(type-id)`实现的强制类型转换

```c++

#include <stdio.h>

int main(int argc, char **argv)
{
	double d = 100.1;
	int i = d;  // double转为int
	char *str = "100ask.taobao.com";
	//reinterpret_cast<type-id>(expression)表示强制类型转换，但是没有运行时类型检查来保证转换的安全性。少用。
	int *p = reinterpret_cast<int *>(str); // char *转为int * 
	
	printf("i = %d, str = 0x%x, p = 0x%x\n", i, reinterpret_cast<unsigned int>(str), reinterpret_cast<unsigned int>(p));

	return 0;
}
```

执行`g++ -o convert3 convert3.cpp `

![image-20230518010541211](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/image-20230518010541211.png)

丢失精度原因，编译机器为64位,64位的机器上指针是8字节的，`usingned int`是4字节。

解决办法，使用32位的交叉编译工具链

![image-20230518010759780](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/image-20230518010759780.png)



## 例程2:const_cast

格式：`const_cast<type_id> (expression)`

该运算符用来去除原来类型的const或volatile属性。

除了`const `或`volatile`修饰之外，` type_id`和`expression`的类型是一样的。

```c++

#include <stdio.h>

int main(int argc, char **argv)
{
	double d = 100.1;
	int i = d;  // double转为int
	//const表示只读，不能修改，但是可以强制转换为非const，
	//这里如果没有加const，编译器会报warning，因为const char *转为char *是不安全的。
	const char *str = "100ask.taobao.com";
	
	//加上const_cast表示强制转换为非const
	char *str2 = const_cast<char *>(str);

	//reinterpret_cast<type-id>表示把一个指针转换为另一个指针类型
	int *p = reinterpret_cast<int *>(str2); // char *转为int * 

	printf("i = %d, str = 0x%x, p = 0x%x\n", i, reinterpret_cast<unsigned int>(str), reinterpret_cast<unsigned int>(p));

	return 0;
}
```

![image-20230518012003554](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/image-20230518012003554.png)