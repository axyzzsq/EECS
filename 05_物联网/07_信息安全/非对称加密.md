# 非对称加密

## 一、非对称加密通讯过程

Step1、小明确定了自己的私钥 mPrivateKey，公钥 mPublicKey。自己保留私钥，将公钥mPublicKey发给了小红;

Step2、小红确定了自己的私钥 hPrivateKey，公钥 hPublicKey。自己保留私钥，将公钥 hPublicKey 发给了小明;

Step3、小明发送信息 “周六早10点soho T1楼下见”，并且用小红的公钥 hPublicKey 进行加密;

Step4、小红收到信息后用自己的私钥 hPrivateKey 进行解密。然后回复 “收到，不要迟到” 并用小明的公钥mPublicKey加密;

Step5、小明收到信息后用自己的私钥 mPrivateKey 进行解密。

以上过程是一次完整的request和response。通过这个例子我们梳理出一次信息传输的非对称加、解密过程：

1、消息**接收方**准备好公钥和私钥

2、私钥**接收方**自己留存、公钥发布给消息**发送方**

3、消息**发送方**使用接收方公钥对消息进行加密

4、消息**接收方**用自己的私钥对消息解密

## 二、非对称加密建立过程

第一次通讯的时候，用户A把自己的公钥发给用户B；用户如何判定信息确实来自用户A而不是伪信息源？

用户A、B之间第一次通讯，互不信任，但是共同信任由政府背书的CA。

### 1、用户向CA申请证书过程



### 2、用户双方的认证







## 三、数字签名

数字签名验证的过程：

![preview](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/202209151117395.jpeg)

图中用户A使用数字签名向用户B传输文件的过程：

1、首先，文件经过[单向散列函数](https://www.zhihu.com/search?q=单向散列函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"469646140"})的处理得到一份占128位的摘要。其中，文件和文件的摘要具有很强的对应关系，只要文件发生改动，经过单向散列函数处理后得到地摘要都会不一样。

2、用户A使用自己的私钥对摘要进行加密，得到加密的摘要。

3、用户A把文件、加密的摘要和公钥一起发给用户B。

4、用户B收到A传过来的信息后，首先将其中的文件也采用单向散列函数处理得出一份128位摘要，然后使用A的公钥对收到的加密的摘要进行解密得到另一份128位摘要。

5、把上一步得到的两份摘要进行比较，如果两份摘要相等，说明文件经过用户A签名之后，在传输的过程中没有被更改；若不相等，说明文件在传输过程中被更改了，或者说已经不是原来的文件了，此时用户A的签名失效。

上面过程中，用户A使用私钥对由文件生成的128位摘要进行加密的过程称为**数字签名的过程**，得到的**"加密的摘要"**，称为该文件的**[数据签名](https://www.zhihu.com/search?q=数据签名&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"469646140"})**。

上面例子传输过程中，用户A使用数字签名时给用户B发送了一个数据包，数据包中包含了A的公钥、文件和加密的摘要。那么问题来了：**用户B如何确定收到的公钥是用户A发送的，而不是他人冒充用户A发送的呢？**这时就需要有一个双方都信任的第三方证书颁发机构来协调。

证书颁发机构，即认证中心**CA** (Certification Authority)，将公钥与其对应的实体（人或机器）进行**绑定**(binding)；即给公司或个人颁发证书。

[认证中心](https://www.zhihu.com/search?q=认证中心&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"469646140"})一般由政府出资建立。每个实体都有CA 发来的**证书**(certificate)，里面有公钥及其拥有者的标识信息。此证书被 CA 进行了数字签名。任何用户都可从可信的地方获得认证中心 CA 的公钥，此公钥用来验证某个公钥是否为某个实体所拥有。



经过CA认证后用户A使用数字签名向用户B传输文件：

![preview](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/202209151119349.jpeg)

用户A向证书颁发机构提交个人信息，申请证书。通过CA审核后，CA生成用户A的证书，证书中包括了A的公钥和私钥还有CA的数字签名。证书颁发机构CA本身拥有一对密钥，这是对CA所颁发的证书进行数字签名和保密的基础，绝不能泄露。

用户A收到的证书中包括了带有CA数字签名的，专属A的公钥和私钥，CA的数字签名确保了别人不能伪造用户A的公钥和私钥。

同时，用户B也必须信任给用户A颁发证书的第三方认证机构CA，即用户B拥有CA颁发的"CA公钥"。

通信时，用户A向用户B发送的数据包中的"加密的摘要"上有用户A的数字签名，“A公钥” 上有认证机构CA的数字签名。用户B收到数据包之后，先要验证收到的 “A公钥” 是否来源合法：是认证机构颁发的带有CA签名的公钥吗？用户B并[不信任](https://www.zhihu.com/search?q=不信任&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"469646140"})用户A，但是用户B信任第三方认证机构CA。所以，用户B先使用证书颁发机构颁发的 "CA公钥" 验证收到的 "A公钥" 是否由同一认证机构颁发，是否在颁发之后更改过。

上一步验证通过后，用户B便相信收到的 "A公钥" 确实来自真实的用户A。随后再使用 "[A公钥](https://www.zhihu.com/search?q=A公钥&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"469646140"})" 对 "加密的摘要" 进行解密得到另一份128位摘要，再将收到信息中的文件也采用单向散列函数处理得出一份128位摘要，然后将得到的两份摘要进行对比操作，以判断文件是否更改。



数字签名是个什么东西呢？它是信息的指纹。但是这不是重点，重点是数字签名的生成过程。数字签名的生成有两个步骤:

- 对明文进行哈希，得到一串哈希值；

- 对第一步得到的哈希值用私钥加密。

![img](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/202209151033414.png)

数字签名是如何使用的呢？其实看一张图就明白了。数字签名会随着内容一起被发送出去，接收方首先用公钥解密数字签名得到哈希值`h1`，然后对内容用同样的算法计算哈希值`h2`，如果`h1=h2`，那么说明内容没有被串改过。

![img](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/202209151033057.png)

然而这个过程也存在风险，如果中间商篡改了公钥，那么他就可以伪造数字签名，一样完蛋。如下

![img](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/202209151038119.png)

所以引入数字证书。

## 四、数字证书

数字证书包含两部分内容：

- 服务器信息
- 数字签名

这里的服务器信息中就包含了服务器的公钥，当然还有一些其他信息，比如证书名称、发布机构、有限期、哈希算法等。数字签名就是对服务器信息进行哈希，然后用CA认证中心的私钥加密的结果。

![img](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/202209151040296.png)

这里特别强调数字签名是用CA认证中心的私钥加密的，因为这样才能防止中间商串改公钥。这里还有一点需要注意，那就是操作系统会自动安装CA认证中心的公钥，所以，每个客户端都默认有CA认证中心的公钥。

![img](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/202209151040738.png)

如果中间商想伪造数字证书，篡改数字证书中的公钥，由于中间商没有CA认证中心的私钥，无法伪造数字签名，于是也就无法伪造数字证书了。

![img](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/202209151040012.png)

但是这样就万无一失了吗？并不是，如果中间商也在CA认证中心注册了数字证书，并且用这个合法的数字证书替换了服务器的数字证书，还是会完蛋。但这就不是我们该操心的问题了，这是CA认证中心该考虑的问题，应该给什么人发证书，拒绝给什么人发证书。只有CA认证中心能够区分好人和坏人，我们才是安全的。
其实到最后就是客户端把对服务器的信任委托给了CA认证中心，因为服务器是不一定可信的，那就创造一个相对一定可信的第三方。

PS:真正的HTTPS通信并不是通过公钥和私钥加密的，公钥和私钥只用在握手过程中，当客户端请求到真正的公钥后，会生成一个随机数（对称密钥）并用公钥加密，发送给服务器，后续的通信就用对称密钥加密了。这样做的原因是非对称加密的性能相对对称加密来说会慢上几倍甚至几百倍，比较消耗系统资源。正是因为如此，https将两种加密结合了起来。