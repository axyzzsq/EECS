# Linux页式内存管理

【导读】

本文讲述Linux如何如何通过MMU从单级页表的内存管理演化到多级页表+TLB组合的分页内存管理。

Linux内存管理是Linux的四大板块之一(内存管理、进程管理、文件系统、设备管理)，并且贯穿其他三大板块，是最重要的内容。

阅读这个页面的内容之前，请关注以下几个问题：

- 单片上能否定义同名的全局变量？为什么？
- 运行Linux的一块芯片上，不同的进程为什么可以定义同名的全局变量？

这个页面的知识点：

- MMU的工作逻辑是什么；
- Linux单级页表为什么会浪费内存?
- Linux多级页表如何省内存？
- Linux如何解决多级页表的效率问题

## 一、内存管理单元

Linux内存管理是通过MMU(内存管理单元)进行，MMU面对应用进程和物理地址，把物理地址分配给不同的进程，让每个进程都感觉自己拥有4GB的内存空间。

类似MMU的这种操作，在生活中也常见。

假设有一个班级甲的师生组队搭乘动车外出，大家独自购票，然后把自己的车厢号座位号登记在班级甲花名册上，此时，老师甲相当于进程，花名册相当于MMU,虽然学生分散在不同的车厢和座位(分散的物理地址)，但是老师甲通过花名册的信息就能访问到所有的学生，而且花名册上看到的大家都是连续的。

![image-20220825152739549](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/image-20220825152739549.png)

在Linux内存管理中，MMU的作用就是在连续的页表上，登记所有的地址信息，再把可用的地址分配给进程。

因为车厢上有很多的座位，班级甲坐不满，班级乙的师生也可以搭乘，此时班级乙的老师手上也有一份花名册，登记了班级乙的学生在车上的位置信息。

 ![image-20220825160806119](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/image-20220825160806119.png)

对班级甲的老师来说，他们班的1号同学是坐在第15节车厢01A座位的哆啦A梦，对于班级乙的老师来说，他们班1号同学虽然也叫坐哆啦A梦，但是坐在02车厢的01A作为，虽然学号相同、名字相同，但是是两个不同的物理实体；

Linux的多进程也是如此，进程程序定义的全局变量是进程内的资源，不与其他进程共享,由MMU负责对变量进行地址转换取值。

由于单片机是单进程，不存在所谓的资源共享或者分配独立资源的问题，所以单片机不能有两个相同的全局变量，否则就会报重定义错误。

## 二、内存分页

### 原理

 ![image-20220825115147692](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/image-20220825115147692.png)

Linux有4GB的内存地址空间，以页的形式进行分割，Linux内存页每页大小为4KB,
$$
4GB = 4KB × 1K × 1K = 4KB × 1M
$$
所以内存空间被分成了1M个页面；

每个页表中每个页需要4Byte来记录信息，页表的大小

​	
$$
4Byte × 1M = 4MB
$$
即每个进程需要4MB的大小存放页表来对4GB的内存地址进行寻址；

 ![image-20220825145616482](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/image-20220825145616482.png)

### 缺陷

页表也是资源，进程之间资源独立，如果运行100个进程，则页表就需要消耗400MB空间，而且即使是很小的进程跑起来，也需要消耗4MB的内存。 

## 三、多级页表

### 原理

为了解决内存分页上多进程会消耗巨大的内存，例如二级页表，将4GB分为1024份，每份中包含1024个页。假设运行了十个进程有20%的一级页表项被使用到了，多级页表模式下，所有进程所使用的页表占据内存为

```matlab
4Byte × 1024份 + 20% × 4MB =  0.804M，
```

传统的一级页表模式下，10个进程使用的页表内存为40M。

### 缺陷

多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。

## 四、多级页表+TLB

### 原理

首先举一个生活中的例子，假设我们要访问公司官网，做法是在百度搜索输入公司的名称，通过百度的回显信息找到公司的页面入口再进入，但是如果经常要访问，每次访问都这样查找效率就不高，就出现了浏览器标签栏，把常用的地址放在标签栏，有需要需要时先看看标签栏上有没有目标地址，有的话直接访问，没有的话再去搜索访问。

![image-20220825153546419](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/image-20220825153546419.png)

类似的如果进程所有的变量访问都去通过MMU转换地址效率就不高，多个进程排队进行地址缓缓的时候就会显得机器卡顿，Linux内存管理提高效率的思路就是把最常访问的几个页表项存储到访问速度更快的硬件，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（*Translation Lookaside Buffer*） ，通常称为页表缓存、快表等。

TLB就相当于浏览器的标签，要访问内存中的变量的时候，优先问询TLB，TLB中没有保存目标对象的时候再通过MMU寻址访问。

![image-20220825155006985](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/image-20220825155006985.png)

