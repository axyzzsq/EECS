# 联合体

[CSDN博文-联合体的使用方法及其本质](https://blog.csdn.net/huqinweI987/article/details/23597091?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166307334016782248587632%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166307334016782248587632&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-23597091-null-null.142^v47^pc_rank_34_queryrelevant25,201^v3^control&utm_term=%E8%81%94%E5%90%88%E4%BD%93%E7%9A%84%E5%A4%A7%E5%B0%8F&spm=1018.2226.3001.4187)

## 1、联合体union的基本特性——和struct的同与不同

union，中文名“联合体、共用体”，在某种程度上类似结构体struct的一种数据结构，共用体(union)和结构体(struct)同样可以包含很多种数据类型和变量。

不过区别也挺明显：

- 结构体(struct)中所有变量是“共存”的——优点是“有容乃大”，全面；缺点是struct内存空间的分配是粗放的，不管用不用，全分配。

- 而联合体(union)中是各变量是“互斥”的——缺点就是不够“包容”；但优点是内存使用更为精细灵活，也节省了内存空间。



## 2、多种访问内存途径共存

```C
//example
#include<stdio.h>
union var{
        long int l;
        int i;
};
main()
{
    union var v;
    v.l = 5;
    printf("v.l is %d\n",v.i);
    v.i = 6;
    printf("now v.l is %ld! the address is %p\n",v.l,&v.l);
    printf("now v.i is %d! the address is %p\n",v.i,&v.i);
} 
```

![image-20220913220610831](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/202209132206899.png)

所以说，管union的叫共用体还真是贴切——完全就是共用一个内存首地址，并且各种变量名都可以同时使用，操作也是共同生效。如此多的access内存手段，确实好用，不过这些“手段”之间却没法互相屏蔽——就好像数组+下标和指针+偏移一样。

上例中我改了v.i的值，结果v.l也能读取，那么也许我还以为v.l是我想要的值呢，因为上边提到了union的内存首地址肯定是相同的，那么还有一种情况和上边类似：

一个int数组变量a，一个long int(32位机中，long int占4字节，与int相同)变量b，我即使没给int变量b赋值，因为数据类型相同，我使用int变量b也完全会拿出int数组a中的a[0]来，一些时候一不小心用上，还以为用的就是变量b呢。

这种逻辑上的错误是很难找出来的（只有当数据类型相去甚远的时候稍好，出个乱码什么的很容易发现错误）。



## 3、联合体union和大小端（big-endian、little-endian）

下边示范了一种用途，代表四个含义的四个变量，但是可以用一个int来操作，直接int赋值，无论内存访问（指针大小的整数倍，访问才有效率），还是时间复杂度（一次和四次的区别，而且这四次有三次都是不整齐的地址），都会低一些。



```cpp
#include<stdio.h>
union var
{
    char c[4];
    int i;
};
 
int main()
{
    union var data;
    data.c[0] = 0x04;//因为是char类型，数字不要太大，算算ascii的范围~
    data.c[1] = 0x03;//写成16进制为了方便直接打印内存中的值对比
    data.c[2] = 0x02;
    data.c[3] = 0x11;
//数组中下标低的，地址也低，按地址从低到高，内存内容依次为：04,03,02,11。总共四字节！
//而把四个字节作为一个整体（不分类型，直接打印十六进制），应该从内存高地址到低地址看，0x11020304，低位04放在低地址上。
    printf("%x\n",data.i);
}
```

 ![image-20220913221454921](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/202209132214956.png)

证明这台机子是小端存储。

## 4、联合体union所占内存空间大小

前边说了，首先，union的首地址是固定的，那么，union到底总共有多大？根据一些小常识，做个不严谨不高深的基础版验证吧。

根据：分配栈空间的时候内存地址基本上是连续的，至少同类型能保证在一起，连续就说明，我如果弄三个结构体出来，他们三个地址应该连着，看一下三个地址的间隔就知道了。

```C
#include<stdio.h>
union sizeTest
{
    int a;
    double b;
};
main()
{
    union sizeTest unionA;
    union sizeTest unionB;
    union sizeTest unionC;

    printf("the initial address of unionA is %p,sizeof unionA:%d\n",&unionA,sizeof(unionA));
    printf("the initial address of unionB is %p,sizeof unionA:%d\n",&unionB,sizeof(unionA));
    printf("the initial address of unionC is %p,sizeof unionA:%d\n",&unionC,sizeof(unionA));
}
```

 ![image-20220913221715468](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/202209132217504.png)

相隔为8.

怕不保险，再改一下，把int改成数组，其他不变：

```cpp
#include<stdio.h>
union sizeTest{
        int a[10];
        double b;
};
main()
{
    union sizeTest unionA;
    union sizeTest unionB;
    union sizeTest unionC;

    printf("the initial address of unionA is %p,sizeof unionA:%d\n",&unionA,sizeof(unionA));
    printf("the initial address of unionB is %p,sizeof unionB:%d\n",&unionB,sizeof(unionB));
    printf("the initial address of unionC is %p,sizeof unionC:%d\n",&unionC,sizeof(unionC));
}
```

 ![image-20220913222225365](https://pic-1304959529.cos.ap-guangzhou.myqcloud.com/DB/202209132222416.png)